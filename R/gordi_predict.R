#' Plot predictors from constrained ordination
#'
#' @description This function takes the result from [gordi_read()] and creates plot with predictor
#' arrows (for continuous variables) and points (for categorical variables, i.e., centroids).
#' Similarly to [gordi_species()] and [gordi_sites()], a wide range of graphing parameters can be set,
#' such as colour, fill, size, shape, alpha, stroke, and more traditional ggplot arguments, which can read
#' both, static and dynamic variable (e.g., 'red' or 'elevation').
#' 
#' @details
#' \itemize{
#'   \item Continuous variables are plotted as \strong{arrows} (biplot scores). The length of the
#'     arrows is scaled by the argument \code{scaling_coefficient}.
#'   \item Categorical variables are plotted as \strong{centroids} of site 'lc' scores (factor scores).
#'   \item \strong{Interactions scores} are calculated directly in this function, because \code{vegan} 
#'     can't calculate all scores for levels of interacting categorical variables. Due to this vector:vector
#'     and vector:factor variables are calculated post-hoc using \code{vegan::envfit} with \code{display = 'lc'}
#'     (linear combinations) and plotted as arrows. Factor:factor interactions are calculated as mean `LC` site
#'     scores for each level combination and plotted as points.
#'   \item Aesthetics (\code{colour}, \code{size}, etc.) are handled dynamically: if the input
#'     matches a column name in the `pass$predictor scores`, it is \strong{mapped} (value of the aestethics
#'     reflects some variable); otherwise, it is treated as a \strong{constant} aesthetic
#'     (every point/arrow have the same colour, size, shape...).
#' }
#'
#'
#' @param pass A list object typically generated by a preceding function (e.g., \code{gordi_read()})
#'   containing the ordination model (\code{pass$m}), scores, and plotting information
#'   (\code{pass$plot}).
#' @param scaling_coefficient A numeric value used to scale the length of the
#'   continuous predictor arrows relative to the overall plot range. A value of \code{0.9}
#'   scales the longest arrow to 90\% of the plot's maximum extent. Scaling coefficient 
#'   applies only to vector variables (arrows).
#' @param label The column name in the \code{pass$predictor_scores} tibble to use for text labels. Options are:
#'   \itemize{
#'     \item \code{'variable_level'} (Default): Combines variable name and variable level (for categorical variables).
#'     \item \code{'variable'}: Just variable names.
#'     \item \code{'level'}: Variable names for continuous variables and just level names for categorical variables (might be better option than the default when the labels are too long.)
#'     \item \code{'custom'}: Uses the labels provided in the \code{custom_labels} argument.
#'   }
#' @param custom_label An optional character vector of labels to use if \code{label = 'custom'}.
#'   Its order and length must exactly match the number of rows in \code{pass$predictor_scores}.description   
#' @param show_label A logical value. If \code{TRUE}, text labels for the predictors are
#'   added to the plot.
#' @param repel_label A logical value. If \code{TRUE}, \code{ggrepel::geom_text_repel}
#'   is used to prevent text labels from overlapping. Requires \code{show_label = TRUE}.
#' @param colour Aesthetic for the predictor points/arrows. Can be a \strong{column name} in
#'   \code{pass$predictor_scores} to map the aesthetic, or a constant color value.
#' @param fill Aesthetic for the fill color of categorical predictor points (centroids).
#'   Accepts column names or constant values.
#' @param alpha Aesthetic for transparency. Accepts column names or constant numeric value (0 to 1).
#' @param linetype Aesthetic for the arrow line type (continuous predictors). Accepts column
#'   names or a constant line type (e.g., \code{1} or \code{'dashed'}).
#' @param linewidth Aesthetic for the arrow line width. Accepts column names or a constant
#'   numeric value.
#' @param shape Aesthetic for the point shape (categorical predictors). Accepts column names
#'   or a constant numeric value (e.g., \code{16} for a solid circle).
#' @param size Aesthetic for the point size (categorical predictors). Accepts column names
#'   or a constant numeric value.
#' @param arrow_size A numeric value defining the size of the arrowhead in **cm** (used with
#'   \code{unit()} from the \code{grid} package).
#'
#'
#' @return The function returns the modified \code{pass} list object, which now contains:
#' \itemize{
#'   \item \code{pass$predictor_scores}: A tibble containing all main and interaction predictor scores.
#'   \item \code{pass$predictor_names}: Updated labels.
#'   \item \code{pass$plot}: The updated \code{ggplot} object with the predictor scores added.
#' }
#'
#' 
#' @importFrom rlang is_empty sym syms expr
#' @importFrom stringr str_detect regex str_extract str_remove str_split str_replace
#' @importFrom dplyr filter mutate bind_cols rename select pull case_when ungroup rowwise distinct across pick
#' @importFrom tidyr unite pivot_longer separate_wider_delim
#' @importFrom purrr discard keep imap_dfr map_chr
#' @importFrom grDevices colours palette
#' @importFrom ggplot2 ggplot theme_bw labs theme element_text element_blank element_rect aes geom_segment arrow unit geom_point ggplot_build geom_text
#' @importFrom ggrepel geom_text_repel
#' @importFrom utils hasName
#' @importFrom tidyselect last_col all_of where
#' @importFrom fastDummies dummy_cols
#' @importFrom vegan envfit scores
#' @importFrom tibble tibble as_tibble
#' @importFrom grid unit
#'
#'
#' @section Constraints:
#' \itemize{
#'   \item The function only supports \strong{constrained ordinations} (\code{RDA}, \code{CCA}, \code{db-RDA}). For plotting passively fitted environmental variables on an unconstrained plot, use \code{\link[gordi]{gordi_corr}}. 
#'   \item The calculation of interaction scores involving continuous variables is only fully supported when the ordination was run with \strong{\code{scaling = 'species'}}
#'   }
#' 
#' 
#' @examples 
#' library(vegan)
#' 
#' data(dune)
#' data(dune.env)
#' 
#' # --- 1. Example with main effects ---
#' m1 <- capscale(dune ~ A1 + Management, data = dune.env)
#' gordi_read(m1, env = dune.env, scaling = 'species', correlation = T) |>
#'    gordi_species(label = F) |>
#'    # Predictors (A1: continuous arrow, Management: categorical centroids)
#'    # Colour is dynamically mapped to the 'score' column (biplot or centroid)
#'    gordi_predict(show_label = T, scaling_coefficient = 1, colour = 'score', size = 4)
#' 
#' # --- 2. Example with an interaction term ---
#' # The interaction term will be calculated post-hoc via envfit
#' m2 <- capscale(dune ~ A1 * Management, data = dune.env)
#' gordi_read(m2, env = dune.env, scaling = 'species', correlation = T) |>
#'    gordi_sites() |>
#'    # Predictors include main effects and interaction effects (e.g., A1:Management)
#'    gordi_predict(show_label = T, repel_label = T, colour = 'score', size = 3)  
#' @export
gordi_predict <- function(
    pass,
    scaling_coefficient = 0.9,
    label = NULL,
    custom_label = NULL,
    show_label = F,
    repel_label = F,
    colour = '',
    fill = '',
    alpha = '',
    linetype = '',
    linewidth = '',
    shape = '',
    size = '',
    arrow_size = 0.3) {
  
  ### initial check
  if (!pass$type %in% c('RDA', 'CCA', 'db-RDA') || rlang::is_empty(pass$predictor_scores)) {
    stop("You provided an unconstrained ordination. Predictors can't be displayed. If you want to passively plot environmental variables, try `gordi_corr()`.")
  }
  
  
  ### ordination axis labels
  if(pass$type %in% c('DCA', 'NMDS')) {actual_labs <- paste0(pass$axis_names)} else
  {actual_labs <- paste0(pass$axis_names, " (", round(pass$explained_variation[pass$choices]*100, 1), "%)")}
  
  ### labels of variables
  valid_labels <- c('variable_level', 'variable', 'level', 'custom')
  label <- match.arg(label, choices = valid_labels)
  
  
  ### which variables do what
  term_labels <- attr(terms(pass$m), "term.labels")
  
  main_terms <- term_labels[!str_detect(term_labels, ':')]
  inter_terms <- term_labels[str_detect(term_labels, ':')]
  
  # check
  #pass$main_terms <- main_terms 
  #pass$inter_terms <- inter_terms
  
  
  ### --- MAIN TERMS ---
  main_terms_scores <- scores(pass$m,
                              scaling = pass$scaling,
                              choices = pass$choices,
                              correlation = pass$correlation,
                              hill = pass$hill,
                              const = pass$const,
                              tidy = T) |>
    as_tibble() |>
    filter(score %in% c('biplot', 'centroids') & !str_detect(label, ':'))
  
  # create NULL objects
  factor_scores <- NULL
  vector_scores <- NULL
  
  # create a tibble with centroid scores
  if (!is.null(main_terms_scores |> filter(score == 'centroids'))) {
    factor_scores <- main_terms_scores |>
      rename(variable_level = label) |> 
      filter(score == 'centroids') |> 
      mutate(variable = stringr::str_extract(
        variable_level,
        pattern = paste(main_terms, collapse = '|')
        )) |> 
      mutate(level = stringr::str_replace(
        variable_level, 
        pattern = variable,
        replacement = ''
        )) |> 
      mutate(variable_level = paste0(variable, '-', level)) |> 
      relocate(c(variable, level, variable_level), .after = score)
  }
  
  # create a tibble with arrow ends
  if (!is.null(main_terms_scores |> filter(score == 'biplot'))) {
    vector_scores <- main_terms_scores |> 
      filter(score == 'biplot') |> 
      rename(variable_level = label) |>
      mutate(variable = stringr::str_extract(
        variable_level,
        pattern = paste(main_terms, collapse = '|')
        )) |>
      mutate(level = variable) |>
      mutate(variable_level = variable) |>
      relocate(c(variable, level, variable_level), .after = score)
    }
  
  #pass$factor_scores <- factor_scores
  #pass$vector_scores <- vector_scores
  
  
  
  ### --- INTERACTION TERMS ---
  vector_inter_scores <- tibble::tibble()
  factor_inter_scores <- tibble::tibble()
  
  interaction_table <- tibble::tibble(
    inter_ID = character(),
    inter_var = character(),
    variable = character(),
    var_class = character()
)
  
  if (length(inter_terms) > 0) {
    
    warning('Interaction scores containing vector variables are fitted post-hoc via envfit as `lc` scores.\n Factor interactions are calculated as centroids of site LC scores for each combination of levels.')
    
    if (is.null(pass$env)) {
      stop('If you want to display interactions, you have to provide env table to the `gordi_read()`.')
    }
    
    # what interacts with what
    interaction_table <- inter_terms |>
      str_split(pattern = ":") |>
      set_names(~ paste0("inter_", seq_along(.))) |>
      imap_dfr(~ tibble(
        inter_ID = .y,
        inter_var = paste0("var", seq_along(.x)),
        variable = .x
      )) |>
      rowwise() |>
      mutate(var_class = case_when(
        !(variable %in% names(pass$env)) ~ 'Not found',
        is.numeric(pass$env[[variable]]) | is.integer(pass$env[[variable]]) ~ 'vector',
        is.factor(pass$env[[variable]]) | is.character(pass$env[[variable]]) ~ 'factor',
        TRUE ~ class(pass$env[[variable]])[1])
      ) |>
      ungroup()
    
  }
  
  #pass$interaction_table <- interaction_table
  
  
  ### --- FOR LOOP ---

  interaction_df_vct <- NULL 
  factor_inter_scores <- NULL

  if (length(inter_terms) > 0) {           

    for (i in pull(distinct(interaction_table, inter_ID))) {

      # prepare a vector with all interaction terms
      inter <- interaction_table |>
        filter(inter_ID == i) |>
        select(variable) |>
        pull()

      # find out which class is which variable
      inter_class <- pass$env |>
        select(all_of(inter)) |>
        map_chr(class)


      # object to hold the result of the current iteration
      current_df_vct <- NULL
      current_df_fct <- NULL 

      # --- NUMERIC x NUMERIC ---
      if (all(inter_class %in% c('numeric', 'integer', 'double'))) {
        current_df_vct <- as_tibble(pass$env[,inter[1]] * pass$env[,inter[2]]) # multiply interacting predictors
        colnames(current_df_vct) <- paste(inter[1], inter[2], sep = ':')       #
      }
  
  
      # --- NUMERIC x FACTOR/CHARACTER ---
      if (any(inter_class %in% c('character', 'factor')) &&
                 any(inter_class %in% c('numeric', 'integer', 'double'))) {

        inter_df_vct <- NULL
        inter_df_fct <- NULL

        if (inter_class[1] %in% c('character', 'factor')) {
          inter_df_fct <- fastDummies::dummy_cols(pass$env[,inter[1]]) |> select(-1)
        } else {
          inter_df_vct <- pass$env[,inter[1]]
        }

        if (inter_class[2] %in% c('character', 'factor')) {
          inter_df_fct <- fastDummies::dummy_cols(pass$env[,inter[2]]) |> select(-1)
        } else {
          inter_df_vct <- pass$env[,inter[2]]
        }

        current_df_vct <- as_tibble(as.vector(inter_df_vct) * as.data.frame(inter_df_fct))
        names(current_df_vct) <- paste(names(inter_df_vct), names(inter_df_fct), sep = ":")
      }
      
      
      if (is.null(interaction_df_vct)) {
        interaction_df_vct <- current_df_vct
      } else {
        interaction_df_vct <- bind_cols(interaction_df_vct, current_df_vct)
      }
      
      
      # --- FACTOR/CHARACTER x FACTOR/CHARACTER ---
      # in this case, it will calculate directly the centroids of LC site scores
      # for each level combination
      
      if (all(inter_class %in% c('character', 'factor'))) {
        var1_name <- inter[1]
        var2_name <- inter[2]

        final_col_name <- paste(var1_name, var2_name, sep = ":")

        current_df_fct <- scores(pass$m,
                                 choices = pass$choices,
                                 scaling = pass$scaling,
                                 correlation = pass$correlation,
                                 hill = pass$hill,
                                 const = pass$const,
                                 tidy = T) |>
          as_tibble() |>
          filter(score == 'constraints') |>
          bind_cols(pass$env) |>
          group_by(pick(all_of(c(var1_name, var2_name)))) |>
          summarize(across(.cols = c(1, 2), # Select columns by their position (1st and 2nd)
                   .fns = ~ mean(.x, na.rm = TRUE))) |>
          ungroup() |>
          unite({{final_col_name}}, where(is.character), sep = ':') |>
          relocate(c(CAP1, CAP2), .before = 1) |> 
          pivot_longer(-where(is.numeric), names_to = 'interacting_variables', values_to = 'level_combinations') |> 
          rename(variable = interacting_variables,
                 level = level_combinations) |> 
          mutate(score = 'centroids') |> 
          separate_wider_delim(variable, delim = ':', names = c('var1', 'var2')) |> 
          separate_wider_delim(level, delim = ':', names = c('level1', 'level2')) |> 
          mutate(variable = paste0(var1, ":", var2),
                 level = paste0(level1, ":", level2),
                 variable_level = paste0(var1, '-', level1, ":", var2, "-", level2)
                 ) |> 
          select(-c(var1, var2, level1, level2))
      }


      if (is.null(factor_inter_scores)) {
        factor_inter_scores <- current_df_fct
      } else {
        factor_inter_scores <- bind_cols(factor_inter_scores, current_df_fct)
      }

    }

  } # end of if() that starts before forloop
   
  #pass$interaction_df_vct <- interaction_df_vct
  #pass$factor_inter_scores <- factor_inter_scores

  
  # --- CACULATE ENVFIT ---
  ### for interactions containing vector only
  vector_inter_scores <- NULL
  
  if (!is_empty(interaction_df_vct)) { 
    
    if (pass$scaling %in% c('si', 'sites', 'sym', 'symm', 'symmetric')) {
      stop('Correct calculation of scores of interactions which include at least one vector variable is currently possible only for scaling = `species`.')
    }
   
    if (pass$scaling %in% c('sp', 'spe', 'species')) {
    
    inter_ef <- envfit(pass$m, env = interaction_df_vct,
                       display = 'lc',
                       scaling = pass$scaling,
                       choices = pass$choices,
                       correlation = pass$correlation,
                       hill = pass$hill)
    
    vector_inter_scores <- as_tibble(scores(inter_ef, display = 'bp'), rownames = 'variable_level') |> 
      relocate(where(is.numeric), .before = 1) |> 
      mutate(variable = stringr::str_extract(
        variable_level,
        pattern = paste(inter_terms, collapse = '|')
        )) |> 
      mutate(level = stringr::str_replace(
        variable_level, 
        pattern = variable,
        replacement = ''
        )) |> 
      mutate(score = 'biplot') |> 
      separate_wider_delim(variable, delim = ':', names = c('var1', 'var2')) |>
      mutate(lvl2 = str_remove(level, '_')) |> 
      mutate(variable = paste0(var1, ":", var2),
             level = paste0(var1, ":", var2, '-', lvl2),
             variable_level = paste0(var1, ":", var2, '-', lvl2)
             ) |> 
      select(-c(var1, var2, lvl2)) |> 
      relocate(c(score, variable, level, variable_level), .after = 2) |> 
      mutate(across(c(level, variable_level), ~ str_remove(.x, '-$')))
     
    } else if (pass$scaling %in% c('no', 'non', 'none')) {
      
    inter_ef <- envfit(pass$m, env = interaction_df_vct,
                       display = 'lc',
                       scaling = pass$scaling,
                       choices = pass$choices,
                       correlation = pass$correlation,
                       hill = pass$hill)
      
    vector_inter_scores <- as_tibble(scores(inter_ef, display = 'bp'), rownames = 'variable_level') |> 
      relocate(where(is.numeric), .before = 1) |> 
      mutate(variable = stringr::str_extract(
        variable_level,
        pattern = paste(inter_terms, collapse = '|')
        )) |> 
      mutate(level = stringr::str_replace(
        variable_level, 
        pattern = variable,
        replacement = ''
        )) |> 
      mutate(score = 'biplot') |> 
      separate_wider_delim(variable, delim = ':', names = c('var1', 'var2')) |>
      mutate(lvl2 = str_remove(level, '_')) |> 
      mutate(variable = paste0(var1, ":", var2),
             level = paste0(var1, ":", var2, '-', lvl2),
             variable_level = paste0(var1, ":", var2, '-', lvl2)
             ) |> 
      select(-c(var1, var2, lvl2)) |> 
      relocate(c(score, variable, level, variable_level), .after = 2) |> 
      mutate(across(c(level, variable_level), ~ str_remove(.x, '-$')))
     
    }

  }
  
  #pass$vector_inter_scores <- vector_inter_scores
  

  # --- MERGE PREDICTOR TABLES together ---
  lst <- list(
    vector_scores = if (!is.null(vector_scores)) {
      vector_scores |> mutate(class = "vector")
      } else {NULL},
    factor_scores = if (!is.null(factor_scores)) {
      factor_scores |> mutate(class = "factor")
      } else {NULL},
    vector_inter_scores = if (!is.null(vector_inter_scores)) {
      vector_inter_scores |> mutate(class = "vector_interaction")
    } else {NULL},
    factor_inter_scores = if (!is.null(factor_inter_scores)) {
      factor_inter_scores |> mutate(class = "factor_interaction")
    } else {NULL} ) |>
    purrr::keep(~ !is.null(.x))
  
  predictor_scores <- lst |>
    imap_dfr(~ .x |> mutate(class = .y))

  pass$predictor_scores <- predictor_scores |>
    rename(Axis_pred1 = 1,
           Axis_pred2 = 2) |> 
    relocate(class, .after = score)
  
  
  
  ### --- ADD CUSTOM LABELS --- ###
  if (label == 'custom') {
    
    if (is.null(custom_label)) {
      stop("If 'label' is set to 'custom', the 'custom_label' argument must be provided.")
      
    } else if (length(custom_label) != nrow(pass$predictor_scores)) {
      
      stop(paste0('The length of `custom label` (',
             length(custom_label),
             ' elements) must match the number of rows in `pass$predictor_scores` (',
             nrow(pass$predictor_scores), ' rows).'))
    } else {
      pass$predictor_scores <- pass$predictor_scores |> 
        bind_cols(
          tibble(custom = custom_label)
        )
      }
  }
  
  pass$predictor_names <- pass$predictor_scores[[label]]

  ### --- PLOTTING ---

  ### create df used for plotting
  pred_df <- pass$predictor_scores

  if (is.null(pass$plot)) { # checks whether p exists in pass, if not it draws plot
    p <- ggplot() +
      theme_bw() +
      geom_vline(aes(xintercept = 0), linetype = 3, linewidth = 0.2, colour = 'gray15', alpha = 0.6) +
      geom_hline(aes(yintercept = 0), linetype = 3, linewidth = 0.2, colour = 'gray15', alpha = 0.6) +
      labs(x = actual_labs[1], y = actual_labs[2]) +
      theme(
        text = element_text(size = 15),
        panel.grid = element_blank(),
        legend.justification = c(1, 1))
  } else {p <- pass$plot}


  ### Detect mapped vs constant aesthetics
  # colour
  # if colour != "" AND ALSO colour represents a colname present in corr_df, then map_colour is TRUE, otherwise is FALSE
  map_colour <- !identical(colour, '') && (colour %in% names(pred_df))
  # if map_colour is FALSE AND ALSO the thing inputed in arguments is a HEX code or is included in colours() or in palette() (word or number), then use it as const_colour
  const_colour <- !map_colour && (grepl("^#(?:[A-Fa-f0-9]{6}[A-Fa-f0-9]{3})$", colour) || colour %in% grDevices::colours()) || (is.character(colour) && colour %in% palette()) || (is.numeric(colour) && colour %in% seq_along(palette()))
  # fill
  map_fill <- !identical(fill, '') && (fill %in% names(pred_df))
  const_fill <- !map_fill && (grepl("^#(?:[A-Fa-f0-9]{6}[A-Fa-f0-9]{3})$", fill) || fill %in% grDevices::colours()) || (is.character(fill) && fill %in% palette()) || (is.numeric(colour) && colour %in% seq_along(palette()))
  # alpha
  map_alpha <- !identical(alpha, '') && has_name(pred_df, alpha)
  const_alpha <- !map_alpha && is.numeric(alpha)
  # linetype
  map_linetype <- !identical(linetype, '') && has_name(pred_df, linetype)
  const_linetype <- !map_linetype && (is.numeric(linetype) || !identical(linetype,''))
  # linewidth
  map_linewidth <- !identical(linewidth, '') && has_name(pred_df, linewidth)
  const_linewidth <- !map_linewidth && is.numeric(linewidth)
  # shape
  map_shape <- !identical(shape, '') && has_name(pred_df, shape)
  const_shape <- !map_shape && is.numeric(shape)
  # size
  map_size <- !identical(size, '') && has_name(pred_df, size)
  const_size <- !map_size && is.numeric(size)


  ### Set scaling coefficient
  # extract plot frame size (x and y axis lengths)
  vct_tbl <- pred_df |> filter(str_detect(score, 'biplot'))

  if (nrow(vct_tbl) > 0) {
    p_build <- ggplot_build(p)

    plot_range <- c(xmin_plot = p_build$layout$panel_params[[1]]$x.range[1],
                    xmax_plot = p_build$layout$panel_params[[1]]$x.range[2],
                    ymin_plot = p_build$layout$panel_params[[1]]$y.range[1],
                    ymax_plot = p_build$layout$panel_params[[1]]$y.range[2])

    pred_range <- c(xmin_pred = min(vct_tbl[,1], na.rm = T),
                    xmax_pred = max(vct_tbl[,1], na.rm = T),
                    ymin_pred = min(vct_tbl[,2], na.rm = T),
                    ymax_pred = max(vct_tbl[,2], na.rm = T))

    coef <- (max(abs(plot_range)) / max(abs(pred_range))) * scaling_coefficient
  } else {coef <- 1}


  ### Prepare aes arguments for geom_segment()
  # Start with fixed x/y for the base (0,0) and end at the species scores
  aes_args_segment <- list(
    x = 0, y = 0,
    xend = expr(Axis_pred1 * !!coef),
    yend = expr(Axis_pred2 * !!coef)
  )

  if(map_colour) aes_args_segment$colour <- sym(colour)
  if(map_alpha) aes_args_segment$alpha <- sym(alpha)
  if(map_linewidth) aes_args_segment$linewidth <- sym(linewidth)
  if(map_linetype) aes_args_segment$linetype <- sym(linetype)


  ### Prepare constant arguments for geom_point() (mapped first, then defaults if nothing)
  const_args_segment <- list()

  # Add constant arguments for geom_segment() if not mapped
  # colour
  if(!map_colour){
    if(!identical(colour, '')) {const_args_segment$colour <- colour} else {const_args_segment$colour <- 2}}
  # alpha
  if(!map_alpha){
    if(!identical(alpha, '')) {const_args_segment$alpha <- alpha} else {const_args_segment$alpha <- 1}}
  # linetype
  if(!map_linetype){
    if(!identical(linetype, '')) {const_args_segment$linetype <- linetype} else {const_args_segment$linetype <- 1}}
  # linewidth
  if(!map_linewidth){
    if(!identical(linewidth, '')) {const_args_segment$linewidth <- linewidth} else {const_args_segment$linewidth <- 1}}
  # arrow_size (does not make sense to have map_arrow)
  const_args_segment$arrow <- arrow(
    length = unit(
      if (!identical(arrow_size, '')) as.numeric(arrow_size) else 0.3, "cm"))


  ### Add ARROWS to plot
  if (!is.null(pred_df |> filter(str_detect(score, 'biplot')))) {
    p <- p + do.call(geom_segment,
                     c(list(data = pred_df |> filter(str_detect(score, 'biplot')),
                            mapping = do.call(aes, aes_args_segment)),
                       const_args_segment))

    if (isTRUE(show_label)){

      aes_args_text <- list(
        x = expr(Axis_pred1 * !!coef),
        y = expr(Axis_pred2 * !!coef),
        label = sym(label)
      )

      if(map_colour) aes_args_text$colour <- sym(colour)
      if(map_alpha) aes_args_text$alpha <- sym(alpha)

      ### Prepare constant arguments for geom_text() (mapped first, then defaults if nothing)
      const_args_text <- list(
        show.legend = F
      )

      if(!map_colour){ if(!identical(colour, '')) {const_args_text$colour <- colour} else {const_args_text$colour <- 'gray20'}}
      if(!map_alpha){ if(!identical(alpha, '')) {const_args_text$alpha <- alpha} else {const_args_text$alpha <- 1}}


      if (isTRUE(repel_label)){
        p <- p + do.call(ggrepel::geom_text_repel,
                         c(list(data = pred_df |> filter(str_detect(score, 'biplot')),
                                mapping = do.call(aes, aes_args_text)),
                           const_args_text))

      } else {
        p <- p + do.call(geom_text,
                         c(list(data = pred_df |> filter(str_detect(score, 'biplot')),
                                mapping = do.call(aes, aes_args_text)),
                           const_args_text))
      }
    }
  }



  ### Categorical variables

  ### Prepare aes arguments for geom_point()
  aes_args_point <- list(
    x = sym("Axis_pred1"),
    y = sym("Axis_pred2")
  )

  if(map_colour) aes_args_point$colour <- sym(colour)
  if(map_fill) aes_args_point$fill <- sym(fill)
  if(map_alpha) aes_args_point$alpha <- sym(alpha)
  if(map_shape) aes_args_point$shape <- sym(shape)
  if(map_size) aes_args_point$size <- sym(size)

  ### Prepare constant arguments for geom_point()
  const_args_point <- list()

  if(!map_colour){
    if(!identical(colour, '')) {const_args_point$colour <- colour} else {const_args_point$colour <- 2}}
  if(!map_fill){
    if(!identical(fill, '')) {const_args_point$fill <- fill} else {const_args_point$fill <- 2}}
  if(!map_alpha){
    if(!identical(alpha, '')) {const_args_point$alpha <- alpha} else {const_args_point$alpha <- 1}}
  if(!map_shape){
    if(!identical(shape, '')) {const_args_point$shape <- shape} else {const_args_point$shape <- 16}}
  if(!map_size){
    if(!identical(size, '')) {const_args_point$size <- size} else {const_args_point$size <- 2}}


  ### Add POINTS to plot
  if (!is.null(pred_df |> filter(str_detect(score, 'centroids')))) {

    p <- p + do.call(geom_point,
                     c(list(data = pred_df |> filter(str_detect(score, 'centroids')),
                            mapping = do.call(aes, aes_args_point)),
                       const_args_point))


    if (isTRUE(show_label)){

      aes_args_text <- list(
        x = sym("Axis_pred1"),
        y = sym("Axis_pred2"),
        label = sym(label)
      )

      if(map_colour) aes_args_text$colour <- sym(colour)
      if(map_alpha) aes_args_text$alpha <- sym(alpha)

      ### Prepare constant arguments for geom_text() (mapped first, then defaults if nothing)
      const_args_text <- list(
        show.legend = F
      )

      if(!map_colour){ if(!identical(colour, '')) {const_args_text$colour <- colour} else {const_args_text$colour <- 'gray20'}}
      if(!map_alpha){ if(!identical(alpha, '')) {const_args_text$alpha <- alpha} else {const_args_text$alpha <- 1}}


      if (isTRUE(repel_label)){
        p <- p + do.call(ggrepel::geom_text_repel,
                         c(list(data = pred_df |> filter(str_detect(score, 'centroids')),
                                mapping = do.call(aes, aes_args_text)),
                           const_args_text))
      } else {
        p <- p + do.call(ggrepel::geom_text_repel,
                         c(list(data = pred_df |> filter(str_detect(score, 'centroids')),
                                mapping = do.call(aes, aes_args_text)),
                           const_args_text))
      }
    }
  }



  pass$plot <- p


  return(pass)
  
}