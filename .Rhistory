# colour
if(!map_colour){
if(!identical(colour, '')) {const_args_point$colour <- colour} else {const_args_point$colour <- 4}}
# alpha
if(!map_alpha){
if(!identical(alpha, '')) {const_args_point$alpha <- alpha} else {const_args_point$alpha <- 1}}
# size
if(!map_size){
if(!identical(size, '')) {const_args_point$size <- size} else {const_args_point$size <- 3}}
# shape
if(!map_shape){
if(!identical(shape, '')) {const_args_point$shape <- shape} else {const_args_point$shape <- 16}}
# fill
if(!map_fill){
if(!identical(fill, '')) {const_args_point$fill <- fill} else {const_args_point$fill <- "white"}}
# stroke
if(!map_stroke){
if(!identical(stroke, '')){const_args_point$stroke <- stroke} else {const_args_point$stroke <- 0.5}}
### Prepare aes arguments for geom_segment()
# Start with fixed x/y for the base (0,0) and end at the species scores
aes_args_segment <- list(
x = 0, y = 0,
xend = quote(Axis_spe1),
yend = quote(Axis_spe2)
)
if(map_colour) aes_args_segment$colour <- sym(colour)
if(map_linewidth) aes_args_segment$linewidth <- sym(linewidth)
if(map_linetype) aes_args_segment$linetype <- sym(linetype)
if(map_alpha) aes_args_segment$alpha <- sym(alpha)
### Prepare constant arguments for geom_point() (mapped first, then defaults if nothing)
const_args_segment <- list()
# Add constant arguments for geom_segment() if not mapped
# colour
if(!map_colour){
if(!identical(colour, '')) {const_args_segment$colour <- colour} else {const_args_segment$colour <- 4}}
# alpha
if(!map_alpha){
if(!identical(alpha, '')) {const_args_segment$alpha <- alpha} else {const_args_segment$alpha <- 0.6}}
# linetype
if(!map_linetype){
if(!identical(linetype, '')) {const_args_segment$linetype <- linetype} else {const_args_segment$linetype <- 1}}
# linewidth
if(!map_linewidth){
if(!identical(linewidth, '')) {const_args_segment$linewidth <- linewidth} else {const_args_segment$linewidth <- 0.5}}
# arrow_size (does not make sense to have map_arrow)
const_args_segment$arrow <- arrow(
length = unit(
if (!identical(arrow_size, '')) as.numeric(arrow_size) else 0.3, "cm"))
#' Add the layer
#' If linear ordination is used (PCA, RDA, PCoA, db-RDA), arrows are used
#' if unimodal (CA, CCA, DCA, NMDS), points are used
if (is.null(symbol) || any(symbol == "default")) {
if (pass$type %in% c('CA', 'CCA', 'DCA', 'NMDS')) {
p <- p + do.call(geom_point, c(list(mapping = do.call(aes, aes_args_point), data = spe_df), const_args_point))
} else {
p <- p + do.call(geom_segment, c(list(data = spe_df, mapping = do.call(aes, aes_args_segment)), const_args_segment))
}
} else if (symbol == 'point') {
p <- p + do.call(geom_point, c(list(mapping = do.call(aes, aes_args_point), data = spe_df), const_args_point))
} else if (symbol == 'arrow') {
p <- p + do.call(geom_segment, c(list(data = spe_df, mapping = do.call(aes, aes_args_segment)), const_args_segment))
}
#
if (isTRUE(label)){
if (isTRUE(repel_label)){
p <- p + geom_text_repel(data = spe_df, aes(Axis_spe1, Axis_spe2, label = species_names), colour = 'black')
} else {
p <- p + geom_text(data = spe_df, aes(Axis_spe1, Axis_spe2, label = species_names), colour = 'black')
}
}
# More scales possibility (e.g. one colour in sites and other in species)
p <- p + ggnewscale::new_scale('size')
p <- p + ggnewscale::new_scale('shape')
p <- p + ggnewscale::new_scale('alpha')
p <- p + ggnewscale::new_scale('stroke')
# Save plot into pass
pass$plot <- p
# Return pass
return(pass)
}
gordi_read(m)
dune.env
m <- capscale(dune ~ A1, data = dune.env)
gordi_read(m)
gordi_read(m, env = dune.env) |>
gordi_species()
gordi_read(m, env = dune.env, scaling = 'species') |>
gordi_species()
gordi_read(m, env = dune.env, scaling = 'species', correlation = T) |>
gordi_species()
gordi_read(m, env = dune.env, scaling = 'species', correlation = T) |>
gordi_species(label = F)
gordi_read(m, env = dune.env, scaling = 'species', correlation = T) |>
gordi_species(label = F) |>
gordi_predict()
gordi_read(m, env = dune.env, scaling = 'species', correlation = T) |>
gordi_species(label = F) |>
gordi_predict(scaling_coefficient = 0.7)
gordi_read(m, env = dune.env, scaling = 'species', correlation = T) |>
gordi_species(label = F) |>
gordi_predict(scaling_coefficient = 1)
#' Draw ordination sites.
#'
#' Draw ordination sites.
#'
#' @description
#' The function [gordi_sites()] takes the result of [gordi_read()] and adds sites (as points)
#' and labels (optional) to a ggplot object created by the function itself.
#' In addition to drawing sites you can change a wide range of parameters.
#' In the process it renames ordination axes to Axis_site1 and Axis_site2, while the original vegan names
#' are passed to 'actual_labs' used for plotting.
#'
#' @details
#' The function builds a dataframe 'site_df' by binding 'pass&env' and 'pass$site_scores'.
#' Aesthetics can be mapped by passing a column name present in the site_df dataframe or by using literal values (e.g. hex colour, numeric size).
#' Fresh colour/fill scales are started for the site layer by ggnewscale::new_scale_colour() and/or ggnewscale::new_scale_fill(), so that later calls (e.g. gordi_colour, layers addded after sites) can define their own independent colour/fill scales.
#' Additional fresh scales (for size, alpha, stroke, shape) are created at the end of the function, so subsequent layers do not inherit site mappings.
#' If label = TRUE, site labels are drawn using the first column in site_df dataframe.
#' The default setting for repel_label is TRUE, so the labels are drawn using `geom_text_repel()`.
#' For changing colour and label aesthetics please refer to [gordi_colour()] and [gordi_label()].
#'
#' @param pass A list object produced by [gordi_read()]
#' The function updates and returns this object.
#' @param label Logical, default is `TRUE`. Draws site labels (`TRUE`) or not (`FALSE`).
#' Site labels can use only the first column of 'site_df', if you want custom labels,
#' please use function [gordi_label()], which overrides label layer settings.
#' @param fill Changes site fill colour. Can be either:
#' - a variable = a specific column name of 'site_df'
#' - a constant value: R colour name, numeric value or hex (e.g. `'green'`, `1`, `'#6aa84f'`)
#' When left as `''`, the internal default colours are used.
#' @param colour Changes site colours. Can be either:
#' - avariable = a specific column name of 'site_df'
#' - a constant value: R colour name, numeric value or hex (e.g. `'green'`, `1`, `'#6aa84f'`)
#' When left as `''`, the internal default colours are used.
#' @param alpha Changes transparency of points.
#' Defined as numeric values.
#' When left as `''`, the internal default values are used (alpha = 1).
#' @param stroke Change shape or arrow width.
#' Defined as numeric values.
#' When left as `''`, the internal default values are used (stroke = 0.5).
#' @param shape Change the shape of points. Either by a specific mapping column from site_df or by a constant (numeric value).
#' When left as `''`, the internal default values are used (shape = 16).
#' @param size Change the size of points. Either by a specific mapping column from site_df or by a constant (numeric value).
#' When left as `''`, the internal default values are used (size = 3).
#' @param repel_label The labels are drawn by [geom_text_repel()].
#' The default is set to repel_label = TRUE.
#'
#' @return The updated 'pass' object with site layers appended to `pass$plot`.
#'
#' @examples
#' o <- gordi_read(m, dune.env)
#'
#' basic sites plot with default styling and labels
#' o|>
#' gordi_sites()
#'
#' mapped colour and size from env dataset, constant alpha, shape, fill
#' o|>
#' gordi_sites(colour = 'elevation', size = 'elevation', alpha = 0.7, shape = 21, fill = 'white')
#'
#' no labels, constant green coloured points
#' o|>
#' gordi_sites(label = FALSE, colour = 'green')
#'
#' @seealso [gordi_read()], [gordi_species()], [gordi_label()], [gordi_colour()],[gordi_predict()], [ggplot2::ggplot()], [ggrepel::geom_text_repel()]
#' @export
# gordi_sites()
library(vegan)
library(tidyverse)
library(ggrepel)
gordi_sites <- function(pass,
label = TRUE,
fill = '',
alpha = '',
stroke = '',
shape = '',
size = '',
colour = '',
repel_label = T) {
#' axis names
names(pass$site_scores) <- paste0("Axis_site", 1:2)
#' actual labs
if(pass$type %in% c('DCA', 'NMDS')) {actual_labs <- paste0(pass$axis_names)} else
{actual_labs <- paste0(pass$axis_names, " (", round(pass$explained_variation[pass$choices]*100, 2), "%)")}
#' plot set up
if (is.null(pass$plot)) {
p <- ggplot() +
theme_bw() +
labs(x = actual_labs[1], y = actual_labs[2]) +
theme(
text = element_text(size = 15),
panel.grid = element_blank(),
legend.justification = c(1, 1)
)
} else {
p <- pass$plot
}
p <- p + ggnewscale::new_scale_colour()
p <- p + ggnewscale::new_scale_fill()
site_df <- bind_cols(pass$env, pass$site_scores)
#' #' accounting for labeling
#' if (label != '') {
#'   if (repel_label) {
#'     p <- p + geom_text_repel(data = site_df, aes(Axis_site1, Axis_site2, label = !!sym(label)))
#'   } else {
#'     p <- p + geom_text(data = site_df, aes(Axis_site1, Axis_site2, label = !!sym(label)))
#'   }
#' }
#'
# Detect mapped vs constant aesthetics
map_colour <- !identical(colour, '') && has_name(site_df, colour)
const_colour <- const_colour <- !map_colour && (grepl("^#(?:[A-Fa-f0-9]{6}[A-Fa-f0-9]{3})$", colour) || colour %in% grDevices::colours()) || (is.character(colour) && colour %in% palette()) || (is.numeric(colour) && colour %in% seq_along(palette()))
map_size <- !identical(size, '') && has_name(site_df, size)
const_size <- !map_size && is.numeric(size)
map_shape <- !identical(shape, '') && has_name(site_df, shape)
const_shape <- !map_shape && is.numeric(shape)
map_fill <- !identical(fill, '') && has_name(site_df, fill)
const_fill <- !map_fill && (grepl("^#(?:[A-Fa-f0-9]{6}[A-Fa-f0-9]{3})$", fill) || fill %in% grDevices::colours())
map_alpha <- !identical(alpha, '') && has_name(site_df, alpha)
const_alpha <- !map_alpha && is.numeric(alpha)
map_stroke <- !identical(stroke, '') && has_name(site_df, stroke)
const_stroke <- !map_stroke && is.numeric(stroke)
# Prepare aes arguments (only mapped)
aes_args_point <- list(x = quote(Axis_site1), y = quote(Axis_site2))
if(map_colour) aes_args_point$colour <- sym(colour)
if(map_size) aes_args_point$size <- sym(size)
if(map_shape) aes_args_point$shape <- sym(shape)
if(map_fill) aes_args_point$fill <- sym(fill)
if(map_alpha) aes_args_point$alpha <- sym(alpha)
if(map_stroke) aes_args_point$stroke <- sym(stroke)
# Prepare constant arguments (mapped first, then defaults if nothing)
const_args_point<- list()
if(!map_colour) {
if(!identical(colour, '')) {
const_args_point$colour <- colour} else {const_args_point$colour <- 1}}
if(!map_size) {
if(!identical(size, '')) {
const_args_point$size <- size} else {const_args_point$size <- 3}}
if(!map_shape) {
if(!identical(shape, '')) {
const_args_point$shape <- shape} else {const_args_point$shape <- 16}}
if(!map_fill) {
if(!identical(fill, '')) {
const_args_point$fill <- fill} else {const_args_point$fill <- 'white'}}
if(!map_alpha) {
if(!identical(alpha, '')) {
const_args_point$alpha <- alpha} else {const_args_point$alpha <- 1}}
if(!map_stroke){
if(!identical(stroke, '')){
const_args_point$stroke <- stroke} else {const_args_point$stroke <- 0.5}}
#' plot
p <- p + do.call(geom_point, c(list(mapping = do.call(aes, aes_args_point), data = site_df), const_args_point))
if (isTRUE(label)){
labcol <- names(site_df)[1]
if (isTRUE(repel_label)){
p <- p + geom_text_repel(data = site_df, aes(Axis_site1, Axis_site2, label = !!sym(labcol)), colour = 'black')
} else {
p <- p + geom_text(data = site_df, aes(Axis_site1, Axis_site2, label = !!sym(labcol)), colour = 'black')
}
}
#' accounting for indiviidual geom scales
#' p <- p + ggnewscale::new_scale("fill")
#' p <- p + ggnewscale::new_scale_colour()
p <- p + ggnewscale::new_scale("size")
p <- p + ggnewscale::new_scale("shape")
p <- p + ggnewscale::new_scale("alpha")
p <- p + ggnewscale::new_scale("stroke")
pass$plot <- p
return(pass)
}
}
#' Extracts predictor scores and relevant stuff and creates plot
#'
#' @description
#' [gordi_predict()] takes the result of [gordi_read()] and creates plot with
#' predictor arrows. So far, it can work with continuous explanatory variables,
#' as for categorical we need to come up with a way how to calculate scores
#' for the last category. It also can't shdisplay explanatory variables passively.
#' There will be a special function for this, maybe something as
#' `gordi_passive_agressive()`. Similarly to [gordi_species()] and [gordi_sites()],
#' you can also set a wide range of graphing parameters, such as colour, fill, size,
#' shape, alpha, stroke, and more traditional ggplot arguments, which can read
#' both, static and dynamic variable (e.g., 'red' or 'elevation').
#'
#' @param pass Object from [gordi_read()] function.
#' @param label Logical; default = T, whether to display label by each point/arrow
#'   or not. In [gordi_predict()], label can be only `predictor_names`, which are
#'   displayed as a full name. If you want to customize the labels, you can it
#'   with [gordi_label()] function, which overrides this setting.
#' @param colour Colour can be defined statically as word from the [colours()]
#'   list (e.g. 'red'), HEX code (e.g. #5d782e), or number from [palette()] (e.g. 3).
#'   It can also defined dynamically (according to some variable, e.g. elevation
#'   or vegetation type). This variable has to be present in the `env` table and its
#'   name has to be written in "quotation marks". Default colour of arrows is 4.
#' @param alpha Transparency of symbols. Numeric value. Default is 0.6. Can be set
#'   statically or dynamically (use "").
#' @param arrow_size Changes the size of arrow. Numeric value. Default is 0.3 cm.
#'   Can't be set dynamically. Just can't. Why would you do that.
#' @param linewidth Self-explanatory. Can be numerical value. See
#'   [aes_linetype_size_shape()] for more details.
#' @param linetype Changes type of line used in arrows. Can be specified with either
#'   an integer (0-6), a name (0 = blank, 1 = solid, 2 = dashed, 3 = dotted,
#'   4 = dotdash, 5 = longdash, 6 = twodash). See [aes_linetype_size_shape()] for
#'   more details.
#' @param scaling_coefficient Numeric; edits the lengts of predictor arrow. Default value
#'   is `0.9` which means that the predictor arrow will be as long as 0.9 of
#'   the longest axis displayed in the plotframe.
#' @param repel_label Logical; repels labels of species for better readability.
#'   Default is F. If you want to customize the labels, you can it with
#'   [gordi_label()] function, which overrides this setting.
#'
#'
#'
#' @return The input object `pass` with an updated `plot` element that includes
#'   predictor arrows and labels.
#'
#' @example
#' library(vegan)
#' library(tidyverse)
#' library(ggrepel)
#'
#' data(dune)
#' data(dune.env)
#'
#' m <- capscale(dune ~ A1, data = dune.env)
#' gordi_read(m, env = dune.env, scaling = 'species', correlation = T) |>
#'   gordi_species(label = F) |>
#'   gordi_predict(scaling_coefficient = 1)
#'
#'
#'
gordi_predict <- function(
pass,
label = T,
colour = '',
alpha = '',
arrow_size = '',
linewidth = '',
linetype = '',
scaling_coefficient = 0.9,
repel_label = T) {
# Check if there are any predictors
if (rlang::is_empty(pass$predictor_scores)) {
stop("You did not use any predictor. Add some before calling gordi_predict().")
}
### ordination axis labels
if(pass$type %in% c('DCA', 'NMDS')) {actual_labs <- paste0(pass$axis_names)} else
{actual_labs <- paste0(pass$axis_names, " (", round(pass$explained_variation[pass$choices]*100, 2), "%)")}
### axis names used in spe_df
names(pass$predictor_scores) <- paste0("Axis_pred", 1:2)
### plot
# Creates blank plot if this function is used as the first one after gordi_read()
# or passes already existing plot
if (is.null(pass$plot)) { # checks whether p exists in pass, if not it draws plot
p <- ggplot() +
theme_bw() +
labs(x = actual_labs[1], y = actual_labs[2]) +
theme(
text = element_text(size = 15),
panel.grid = element_blank(),
legend.justification = c(1, 1))
} else {p <- pass$plot}
### create spe_df which is then called in the ggplot (spe_df exists only in this function and does not pass to the next)
pred_df <- bind_cols(pass$predictor_scores, pass$predictor_names)
### Detect mapped vs constant aesthetics
# colour
#' if colour != "" AND ALSO colour represents a colname present in spe_df, then map_colour is TRUE, otherwise is FALSE
map_colour <- !identical(colour, '') && has_name(pred_df, colour)
# if map_colour is FALSE AND ALSO the thing inputed in arguments is a HEX code or is included in colours() or in palette() (word or number), then use it as const_colour
const_colour <- !map_colour && (grepl("^#(?:[A-Fa-f0-9]{6}[A-Fa-f0-9]{3})$", colour) || colour %in% grDevices::colours()) || (is.character(colour) && colour %in% palette()) || (is.numeric(colour) && colour %in% seq_along(palette()))
# alpha
map_alpha <- !identical(alpha, '') && has_name(pred_df, alpha)
const_alpha <- !map_alpha && is.numeric(alpha)
# linetype
map_linetype <- !identical(linetype, '') && has_name(pred_df, linetype)
const_linetype <- !map_linetype && (is.numeric(linetype) || !identical(linetype,''))
# linewidth
map_linewidth <- !identical(linewidth, '') && has_name(pred_df, linewidth)
const_linewidth <- !map_linewidth && is.numeric(linewidth)
### Set scaling coefficient
# extract plot frame size (x and y axis lengths)
p_build <- ggplot_build(p)
plot_range <- c(xmin_plot = p_build$layout$panel_params[[1]]$x.range[1],
xmax_plot = p_build$layout$panel_params[[1]]$x.range[2],
ymin_plot = p_build$layout$panel_params[[1]]$y.range[1],
ymax_plot = p_build$layout$panel_params[[1]]$y.range[2])
predictor_range <- c(xmin_pred = min(pred_df[,1]),
xmax_pred = max(pred_df[,1]),
ymin_pred = min(pred_df[,2]),
ymax_pred = max(pred_df[,2]))
coef <- (max(abs(plot_range)) / max(abs(predictor_range))) * scaling_coefficient
### Prepare aes arguments for geom_segment()
# Start with fixed x/y for the base (0,0) and end at the species scores
aes_args_segment <- list(
x = 0, y = 0,
xend = expr(Axis_pred1 * !!coef),
yend = expr(Axis_pred2 * !!coef)
)
if(map_colour) aes_args_segment$colour <- sym(colour)
if(map_alpha) aes_args_segment$alpha <- sym(alpha)
if(map_linewidth) aes_args_segment$linewidth <- sym(linewidth)
if(map_linetype) aes_args_segment$linetype <- sym(linetype)
### Prepare constant arguments for geom_point() (mapped first, then defaults if nothing)
const_args_segment <- list()
# Add constant arguments for geom_segment() if not mapped
# colour
if(!map_colour){
if(!identical(colour, '')) {const_args_segment$colour <- colour} else {const_args_segment$colour <- 2}}
# alpha
if(!map_alpha){
if(!identical(alpha, '')) {const_args_segment$alpha <- alpha} else {const_args_segment$alpha <- 1}}
# linetype
if(!map_linetype){
if(!identical(linetype, '')) {const_args_segment$linetype <- linetype} else {const_args_segment$linetype <- 1}}
# linewidth
if(!map_linewidth){
if(!identical(linewidth, '')) {const_args_segment$linewidth <- linewidth} else {const_args_segment$linewidth <- 0.7}}
# arrow_size (does not make sense to have map_arrow)
const_args_segment$arrow <- arrow(
length = unit(
if (!identical(arrow_size, '')) as.numeric(arrow_size) else 0.3, "cm"))
### add to plot
p <- p + do.call(geom_segment,
c(list(data = pred_df,
mapping = do.call(aes, aes_args_segment)),
const_args_segment))
if (isTRUE(label)){
labcol <- names(pred_df)[3]
if (isTRUE(repel_label)){
p <- p + geom_text_repel(data = pred_df, aes(Axis_pred1*coef, Axis_pred2*coef, label = !!sym(labcol)), colour = 'black')
} else {
p <- p + geom_text(data = pred_df, aes(Axis_pred1*coef, Axis_pred2*coef, label = !!sym(labcol)), colour = 'black')
}
}
### save plot
pass$plot <- p
return(pass)
}
gordi_read(m, env = dune.env, scaling = 'species', correlation = T) |>
gordi_species(label = F) |>
gordi_predict(scaling_coefficient = 1)
gordi_read(m, env = dune.env, scaling = 'species', correlation = T) |>
gordi_species(label = F) |>
gordi_predict(scaling_coefficient = 0.1)
gordi_read(m, env = dune.env, scaling = 'species', correlation = T) |>
gordi_species(label = F) |>
gordi_predict(scaling_coefficient = 0.1, label = F)
# CCA
m <- cca(spe, data = env)
gordi_read(m, env, trait) |>
gordi_species(label = F, colour = 'form', fill = 'cont', shape = 22, stroke = 1.5) |>
gordi_colour(scale = 'discrete', family = 'viridis', direction = -1) |>
gordi_colour(scale = 'continuous', family = 'brewer', palette_name = 'Set1', fill = T, direction = -1)
library(vegan)
library(tidyverse)
library(ggrepel)
library(readxl)
library(ggnewscale)
# Import -----------------------------------------------------------------------
env <- read_csv("data/schrankogel/schrankogel_env.csv") |>
mutate(group = case_when(elevation > 3000 ~ '1',
elevation <= 3000 & elevation > 2500 ~ '2',
elevation <= 2500 ~ '3',
TRUE ~ 'wtf'),
logger_ID = as.character(logger_ID))
spe <- read_csv('data/schrankogel/schrankogel_spe.csv') |>
mutate(logger_ID = as.character(logger_ID)) |>
select(where(~ sum(. != 0) > 5)) |>
filter(if_any(where(is.numeric), ~ . != 0))
# Import -----------------------------------------------------------------------
env <- read_csv("data/schrankogel/schrankogel_env.csv") |>
mutate(group = case_when(elevation > 3000 ~ '1',
elevation <= 3000 & elevation > 2500 ~ '2',
elevation <= 2500 ~ '3',
TRUE ~ 'wtf'),
logger_ID = as.character(logger_ID))
spe <- read_csv('data/schrankogel/schrankogel_spe.csv') |>
mutate(logger_ID = as.character(logger_ID)) |>
select(where(~ sum(. != 0) > 5)) |>
filter(if_any(where(is.numeric), ~ . != 0))
env <- env |>
semi_join(spe, by = 'logger_ID')
spe <- spe |>
select(!logger_ID) |>
log1p()
trait <- read_xlsx('data/Life_form.xlsx')|>
select(-SeqID)|>
pivot_longer(cols = -FloraVeg.Taxon, names_to = 'form', values_to = 'value') |>
filter(!value == 0) |>
distinct(FloraVeg.Taxon, .keep_all = T) |>
mutate(cont = rep(1:50, length.out = n()))
# partial db-RDA
m <- capscale(spe ~ elevation, data = env)
# partial db-RDA
m <- capscale(spe ~ elevation + Condition(slope), data = env)
m
gordi_read(m)
gordi_read(m) |>
gordi_sites()
gordi_read(m) |>
gordi_sites() |>
gordi_species()
gordi_read(m, scaling = 'symm') |>
gordi_sites() |>
gordi_species()
gordi_read(m, scaling = 'symm') |>
gordi_sites(label = F) |>
gordi_species(label = F)
gordi_read(m, scaling = 'symm') |>
gordi_sites(label = F) |>
gordi_species(label = F) |>
gordi_predict()
