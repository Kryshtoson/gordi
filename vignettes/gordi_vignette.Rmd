---
title: "gordi: Plot ordination diagrams with ggplot2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{"gordi: Plot ordination diagrams with ggplot2"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 6,
  dpi = 300,
  out.width = "100%"
)
```

```{r setup}
library(gordi)
library(vegan)
library(tidyverse)
```

# Introduction

The `gordi` package was developed to help poor students of community ecology deal with community data analysis, especially when it comes to **ordination methods** and their visualization.

With `gordi`, you can:

-   take results from common ordinations in the **vegan** package, particularly:

    -   `rda()` for PCA and RDA
    -   `cca()` for CA and CCA
    -   `capscale()` for PCoA and db-RDA
    -   `metaMDS()` for NMDS
    -   `decorana()` for DCA

-   visualize them quickly with clear and customizable plots via **ggplot2**

-   and have access to **ggplot2** for final polishing

`gordi` is still under construction and changes happen very often, so it might be beneficial, if you update the package as often as possible. Also this may be the reason for slightly different results you may obtain from `gordi` now and tomorrow. `gordi` is not on CRAN yet, as it exists only on Github. It can be installed (or updated) using this code:

```{r eval=FALSE, include=FALSE}
remotes::install_github('Kryshtoson/gordi')
```

## General Workflow

The functions in `gordi` follow some rules regarding the order in which they are called. The most important rule is, that every attempt of using `gordi` has to start with the `gordi_read()` function. The second most important rule is, that `gordi_` functions work the best if applied in a pipeline, because every function uses the output (called `pass`) of the previous one, but it also has a lot of own arguments, so the code will be unreadable very soon if you use the base R nested functions approach.

The ordination analysis as a whole has basically three parts. The first consists of long-lasting and exhausting data preparation and formatting. The poor person (including you, based on the fact that you are reading these lines) usually has to synchronise the taxonomical concepts in the data set, clean it from mistakes, typos, decide what to do with some extraordinary samples and finally put the data into a format, that is acceptable by the analytical software.

In the second part, the model is typically calculated. It tends to be the shortest, but the most important one.

Only in the third part, which is the visualisation of the results, `gordi` comes to the word. In this vignette, we will cover the second (slightly) and the third part. The first part (data preparation) is omitted here, as it is usually highly case specific. But we will mention the format of the data which `gordi` needs to function correctly.

### Steps to Success

1.  The first step is calculating an ordination. The `gordi` package is compatible with the outputs of `vegan` functions mentioned above.

    In this example, we will use the `dune` dataset which is available in the library `vegan` to calculate a simple constrained ordination (db-RDA). We will square-root the species data (familiarly called **spe**) to reduce the influence of the dominant species. As the predictor, we will use the `A1` variable which is available in the environmental table (often called **env**).

```{r}
library(gordi)
library(vegan)
library(tidyverse)

# 1. Load example dataset
data(dune)
data("dune.env")

# 2. Check if the data have the correct format
    # e.g. species table must not contain any ID column,
    # the number of rows in spe and env table must be the same
glimpse(dune)
glimpse(dune.env)
nrow(dune) == nrow(dune.env)

# 3. Calculate the ordination
m <- capscale(sqrt(dune) ~ A1,    
              data = dune.env,    # we have to provide env table with predictors,
                                  # so the model knows where to look for the predictor
              distance = 'bray',  # 'Bray-Curtis dissimilarity' - probably the most used one
              sqrt.dist = T)      # square-rooted Bray-Curtis dissim. does not produce Imaginary Inertia,
                                  # which is problematic, when it comes to determining how much
                                  # variability in the data the model explained
```

2.  Now it is time for the first `gordi` function. `gordi_read()` reads the resulting object of the ordination (**m**) and prepares it for use by other `gordi_` functions. That said, `gordi_read()` has to always be the first one in the pipeline of `gordi_` functions.

    `gordi_read()` has many arguments, which greatly influence how the final plot will look like. You can for example set here the scaling of the plot, select the ordination axes you want to look at. You can also add **env**, **spe** and **traits** data which you can later use for variable based symbolisation of sites or species in the plot or for passive projection of variables onto unconstrained ordination.

    For more details regarding the arguments used in the `gordi_read()` please check the help page of the `scores()` function in the `vegan` package.

    > **Note**: If you look just for the "scores", the help page will be rather laconic. For more details, you have to look for the ordination type specific `scores()` function, such as "scores.rda" or "scores.cca".

    > **Note**: Don't panic when you see the whole long stuff in console. This is the `pass` object which travels through `gordi_` functions and you can easily check if you entered the right data.

```{r}
# Print ordination result
m

# Use `gordi_read()` to read the ordination result
m |> 
  gordi_read(
    choices = 1:2         # we want to look at the first two ordination axes
    scaling = 'species'   # we want to focus on the species
    correlation = T
  )
```

3.  At this point, you actually start plotting. The first decision often is, whether you want to display 'species' or 'sites' (samples) scores. In the previous example we decided, we want to focus on 'species' and we also set the `scaling = 'species'`.

    The scaling influences how the **scores** will be calculated and it basically means, that if we set `scaling = 'species'`, that 'species' will be displayed correctly (i. e. the relative position of the arrows will correctly represent how the species "go together" - the closer, the more). This applies also for the situation when we want to look at the 'sites' (or samples) and we se `scaling = 'sites'`.

    > **Note**: The word "scores" might sound unfamiliar, but don't worry, it is nothing else that the "coordinates" of each species or site in the multidimensional space of the ordination. Each species and each site has its own "score" on each ordination axis.

    On the other hand, if we set `scaling = 'sites'` and then we display 'species', their relative position will be harder to interpret. But it still might be useful to look at both scores (sites and species) in one plot, but you have to have in mind, that only what you scaled for will be displayed correctly.

    There is also a third, compromising option how to display both, species and site (sample) scores at once, and this is `scaling = 'symmetric'`. It basically discorts the scores of both, species and sites, but not that much as when you scale for species and display sites.

    -   If you have decided to display species, use `gordi_species()`
    -   If you have decided to display sites, use `gordi_sites()`

```{r}
m |> 
  gordi_read(choices = 1:2, scaling = 'species', correlation = T) |> 
  gordi_species()
```
    OK, good, we have a bunch of blue arrows now. Each arrow represent one species, but which one? For a quick information, we can set argument `label = T`.
    
```{r}
m |> 
  gordi_read(choices = 1:2, scaling = 'species', correlation = T) |> 
  gordi_species(label = T)
```

    Nice. We can see, that the names of species in the `dune` data set are already shortened, so we have to do nothing more about it. In case, when the data set is not that nicely prepared and you have the whole species names in the column names in the spe table (e.g. *Achillea millefolium agg.*), the plot gets crowded rapidly. For this purposes, there is a handy function `gordi_label()` Which can create nice species names shortcuts. Check its help page.
    
    What else can we improve is the position of the species names, so they do not overlap each other. For this, set the argument `repel_label = T`.
    
```{r}
m |> 
  gordi_read(choices = 1:2, scaling = 'species', correlation = T) |> 
  gordi_species(label = T, repel_label = T)
```

### TADY JSEM SKONCILA

In `gordi_species()` and `gordi_sites()` you can control colour, fill, shape, and many more things regarding symbology. You can e.g. colour symbols by a variable or set colour statically (see help of aforementioned functions for details). However, if you want to further customize colours or shapes, continue to step 4.

```{r}
# At first, we need to prepare traits table to be compatible with species table.
# Basically, it means, that the first column in the traits table must contain
# species names as used in species table
data('dune.taxon')
traits <- as_tibble(dune.taxon, rownames = 'species')

# Now we continue with the gordi pipeline
obj <- m |> gordi_read(env = dune.env,          # table with environmental variables
                traits = traits,     # table with traits, respective in this case,
                                         # table with species names, families and 
                                         # other stuff is used
                choices = 1:2,           # choose 1st and 2nd ordination axes
                correlation = T,
                scaling = 'species') |>  # we want to display species, we choose scaling = 'species'
  gordi_species(colour = 'Subclass',      # colour may be set statically,
                                         # or dynamically, by using name of some
                                         # variable in traits data frame
                alpha = 0.8,             # opacity of symbols
                arrow_size = 0.5)        # changes arrow size (in cm)

obj

```

4.  If you want to select some predefined or custom colour scale or different than default shapes, you have to do it immediately after `gordi_species()` or `gordi_sites()` has been used, using `gordi_colour()` and `gordi_shape()` functions.
    -   `gordi_colour()` controls both, colour and fill
    -   `gordi_shape()` controls point type

```{r}
obj <- obj |> 
  gordi_colour(scale = 'discrete',       # first, you must define the scale (see 
                                         # ?gordi_colour() for options)
               family = 'viridis')        # then you must select from a family of
                                         # colour scales or set one manually 

obj
```

5.  In case, you have calculated constrained ordination (`rda`, `CCA`, `db-RDA`), and you want to display predictor, use `gordi_predict()`. Notice, so far only continuous predictors are allowed.

```{r}
obj <- obj |> 
  gordi_predict(
    colour = 'red',
    alpha = 1,
    arrow_size = 0.5,
    scaling_coefficient = 1,
  )

obj
```

6.  Now, when you finally have all the points and arrows on its places, you may want to label the symbols and customize the labeling - and this is done with `gordi_label()` function which overrides labels displayed by `gordi_species()`, `gordi_sites()` or `gordi_predict()`. Its main advantage comes with **species** because there are many options for creating shortcuts. Unlike `gordi_colour()` and `gordi_shape()` functions, which must be used directly after what they should customize, this function may be used anytime. We suggest to cast it at the end of `gordi_` pipeline.

```{r}
obj <- obj |> 
  gordi_label(what = 'species',        # first, we need to define what we want to label
              label_colour = 'green4',
              size = 2) |> 
  gordi_label(what = 'predictor',
              label_colour = 'red',
              nudge_y = 0.025)

obj
```

For demonstrating the power of shortcuts, we need to update the species names in the dune dataset to full names...

```{r}
# First we create provisional species names containing two words
dune2 <- dune |> 
  rename_with(~str_c(
    substr(traits$species, 1, 4),
    substr(traits$species, 5, 8),
    sep = ' '
  ))

traits2 <- traits |> 
  mutate(species2 = str_c(
    substr(traits$species, 1, 4),
    substr(traits$species, 5, 8),
    sep = ' '
  ), .before = species)

# Second, we calculate new ordination with dune2
obj <- capscale(sqrt(dune2) ~ A1, data = dune.env, distance = 'bray', sqrt.dist = T)

# Third, we build gordi pipeline
obj |> 
  gordi_read(env = dune.env,
             traits = traits2,
             choices = 1:2,
             scaling = 'species',
             correlation = T) |> 
  gordi_species(colour = 'Subclass') |> 
  gordi_colour(scale = 'discrete', family = 'viridis') |> 
  gordi_predict() |> 
  gordi_label(what = 'species',
              shortcut = 'upper_lower',
              shortcut_colour = 'Subclass',
              repel_label = T) |> 
  gordi_colour(scale = 'discrete', family = 'viridis')

obj
```

7.  If you want to further customize the ordination plot with `theme()` functions, you need to do one more thing. After all `gordi_` functions you need to use `gordi_plot()` which extracts the ggplot object and makes it editable by standard `ggplot2` functions, e.g., `theme()`.

> **Note**: Don't forget, that traditional **ggplot2** functions use the `+` sign, not pipe operator `|>`.

```{r}
library(see)
obj <- capscale(sqrt(dune) ~ A1, data = dune.env, distance = 'bray', sqrt.dist = T)

obj |>
   gordi_read(env = dune.env,
             choices = 1:2,
             scaling = 'species',
             correlation = T) |> 
  gordi_species() |> 
  gordi_predict() |> 
  gordi_label(what = 'species',
              label_colour = 'white',
              repel_label = T) |>  
  gordi_plot() +
  theme_abyss() +
  labs(title = 'This is a very nice plot',
       subtitle = 'Do not try to argue with the authors.') +
  geom_point(aes(x = -0.12, y = 0.15), shape = 8, size = 10, colour = 'pink', stroke = 3)
```

## Limitations

Even though `gordi` can do a lot of things, there are still many parts of the intended package, which are now under construction. What you may expect it to do but is not possible yet:

-   displaying results of constrained ordination (`rda`, `CCA`, `db-RDA`) where categorical predictor was used
-   displaying results of constrained ordination with interactions
-   passively project predictors (like in `vegan::envfit()`)
-   displaying 'spiders', 'hulls' and 'ellipses' when you want to symbolise clusters
-   ordisurf
